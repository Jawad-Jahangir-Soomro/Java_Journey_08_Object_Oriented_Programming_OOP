# Java Journey, 08: Object Oriented Programming.

Repository #08: Object-Oriented Programming is a comprehensive guide to one of the most important programming paradigms in Java. The repository covers the fundamental concepts of object-oriented programming, such as encapsulation, inheritance, polymorphism, and abstraction, with examples and exercises to solidify understanding. It also covers key concepts such as interfaces, abstract classes, and the Java object model. By the end of this repository, learners will have a strong foundation in object-oriented programming and will be able to apply these concepts to build efficient and scalable Java applications.

## Learn about objects and classes in Java.

In Java, an object is an instance of a class. A class is a blueprint that defines the attributes and behaviors of an object. Objects are the basic building blocks of object-oriented programming, allowing for modular and reusable code.

To create an object in Java, we need to define a class with the keyword "class" followed by the class name. Within the class, we can define instance variables and methods.

Instance variables are used to represent the state of an object, while methods define the behaviors of an object. We can create multiple instances of a class, each with its own state and behavior.

Java also supports the concept of inheritance, where a class can inherit the attributes and behaviors of another class. This allows for code reuse and simplifies the creation of complex programs.

Understanding objects and classes is a fundamental concept in Java and object-oriented programming, and is essential for developing robust and scalable applications.

## Study the concept of constructors.

In Java, a constructor is a special type of method that is used to initialize objects. It has the same name as the class and no return type. The main purpose of a constructor is to assign initial values to instance variables of an object. Constructors are called automatically when an object is created using the new keyword.

There are two types of constructors in Java: default and parameterized. A default constructor takes no arguments and is automatically generated by the compiler if no other constructors are defined in the class. A parameterized constructor, on the other hand, takes one or more arguments and is used to initialize instance variables with specific values passed as arguments.

Constructors can also be overloaded, which means that a class can have multiple constructors with different parameter lists. This allows for more flexibility in creating objects, as different constructors can be used to initialize objects in different ways.

Overall, constructors are an important concept in object-oriented programming as they allow for the initialization of objects and the creation of multiple objects with different initial values.

## Get an understanding of inheritance in Java, including interfaces and dynamic method dispatch.

### Inheritance

Inheritance is one of the key features of object-oriented programming, and it allows one class to inherit properties and methods from another class. In Java, inheritance is achieved through the "extends" keyword.

Consider the following example:

```bash
public class Animal {
  public void makeSound() {
    System.out.println("Some sound");
  }
}

public class Dog extends Animal {
  public void makeSound() {
    System.out.println("Bark");
  }
}
```

In this example, the Dog class extends the Animal class, which means it inherits the makeSound() method from the Animal class. However, the Dog class overrides the makeSound() method with its own implementation, which prints "Bark" instead of "Some sound".

Another aspect of inheritance is the concept of a superclass and a subclass. The Animal class is the superclass, while the Dog class is the subclass. The subclass can access all the properties and methods of the superclass, as well as define its own.

### Interfaces

Interfaces are also a part of inheritance in Java. An interface is a collection of abstract methods that a class can implement. For example:

```bash
public interface Drawable {
  void draw();
}

public class Circle implements Drawable {
  public void draw() {
    System.out.println("Drawing a circle");
  }
}
```

In this example, the Circle class implements the Drawable interface, which means it must define the draw() method. This allows us to create a collection of objects that all have a common behavior defined by the Drawable interface.

### Dynamic Method Dispatch

Dynamic method dispatch is another feature of inheritance in Java. This allows us to call a method on an object, and have the appropriate implementation of that method be executed based on the actual type of the object, rather than just the declared type. For example:

```bash
Animal animal1 = new Animal();
Animal animal2 = new Dog();

animal1.makeSound(); // prints "Some sound"
animal2.makeSound(); // prints "Bark"
```

In this example, animal1 is an instance of the Animal class, while animal2 is an instance of the Dog class. When we call the makeSound() method on each of these objects, we get different results because the method implementation that is executed depends on the actual type of the object at runtime.

## Study polymorphism, including method overloading and overriding.

Polymorphism is a concept in object-oriented programming that allows objects of different classes to be treated as if they are of the same type. In Java, polymorphism can be achieved through method overloading and method overriding.
Polymorphism is the ability of an object to take on many forms. In Java, there are two types of polymorphism: compile-time polymorphism and runtime polymorphism.

Method overloading is an example of compile-time polymorphism where a class can have multiple methods with the same name but different parameters. When calling the method, the appropriate version is chosen based on the number and types of arguments passed to it.

Here is an example of method overloading:

```bash
public class Calculator {
   public int add(int a, int b) {
      return a + b;
   }
   
   public double add(double a, double b) {
      return a + b;
   }
   
   public int add(int a, int b, int c) {
      return a + b + c;
   }
}
```

Method overriding is an example of runtime polymorphism where a subclass can provide its own implementation of a method defined in the superclass. When calling the method on an object of the subclass, the overridden method in the subclass is executed.

Here is an example of method overriding:

```bash
public class Animal {
   public void makeSound() {
      System.out.println("The animal makes a sound");
   }
}

public class Cat extends Animal {
   @Override
   public void makeSound() {
      System.out.println("Meow");
   }
}

public class Dog extends Animal {
   @Override
   public void makeSound() {
      System.out.println("Woof");
   }
}
```

In the above example, the Cat and Dog classes override the makeSound() method of the Animal class with their own implementation.

Dynamic method dispatch allows us to call the overridden method from the subclass even if the object reference is of the superclass. This is done using the super keyword.

Here is an example of dynamic method dispatch:

```bash
Animal animal = new Cat();
animal.makeSound(); // prints "Meow"
```

In the above example, even though the animal object reference is of type Animal, the makeSound() method of the Cat class is executed due to dynamic method dispatch.

Polymorphism allows for code reusability, modularity, and flexibility. It simplifies the coding process by allowing programmers to create generic code that can handle multiple data types or objects, rather than having to write separate code for each type.

## Learn about encapsulation and abstraction in Java.

Encapsulation and Abstraction are two important concepts in Object-Oriented Programming. Encapsulation is the process of hiding implementation details of an object from the outside world and providing access only through public methods. Abstraction is the process of providing a simplified view of complex systems by hiding unnecessary details.

In Java, encapsulation is implemented through access modifiers such as public, private, and protected, which control the visibility of methods and variables. Abstraction is implemented through abstract classes and interfaces, which provide a way to define a common interface for a group of related classes.

Using encapsulation and abstraction helps in achieving data hiding, reducing complexity, improving maintainability, and increasing reusability of code.

### Encapsulation

Encapsulation is one of the four fundamental concepts of object-oriented programming (OOP) in Java. It refers to the practice of enclosing the fields and methods of a class within a protective boundary, or "capsule," to prevent unauthorized access and modification.

In encapsulation, the data of an object is accessed only through its public methods or interfaces, while the inner workings of the object remain hidden. This helps to maintain data integrity, security, and flexibility in the code.

For example, let's consider a class called BankAccount that has private fields such as balance and accountNumber. By making these fields private and providing public methods like getBalance() and deposit(), we can control access to these fields and ensure that they are modified only in a controlled manner.

Here is an example of a BankAccount class with encapsulated data:

```bash
public class BankAccount {
    private int accountNumber;
    private double balance;

    public BankAccount(int accountNumber, double balance) {
        this.accountNumber = accountNumber;
        this.balance = balance;
    }

    public int getAccountNumber() {
        return accountNumber;
    }

    public double getBalance() {
        return balance;
    }

    public void deposit(double amount) {
        balance += amount;
    }
}
```

In this example, the fields accountNumber and balance are declared as private to protect them from unauthorized access or modification. The getAccountNumber(), getBalance(), and deposit() methods are provided to allow controlled access to these fields.

Encapsulation is an important concept in Java as it helps to create more robust and secure code, and allows for easier maintenance and modification of code over time.

### abstraction

Abstraction in Java is a mechanism to show only the relevant information of an object to the user and hide the rest. It is achieved through the use of abstract classes and interfaces.

Abstract classes are classes that cannot be instantiated and can have both concrete and abstract methods. They can also have instance variables and constructors. The abstract methods do not have a body and are defined in the subclasses.

Example:

```bash
abstract class Shape {
    int x, y;
    public Shape(int x, int y) {
        this.x = x;
        this.y = y;
    }
    abstract void draw();
}

class Rectangle extends Shape {
    int width, height;
    public Rectangle(int x, int y, int width, int height) {
        super(x, y);
        this.width = width;
        this.height = height;
    }
    void draw() {
        System.out.println("Drawing a rectangle at (" + x + ", " + y + ") with width " + width + " and height " + height);
    }
}
```

In this example, the Shape class is abstract and has an abstract method draw(). The Rectangle class extends Shape and implements the draw() method.

Interfaces in Java are similar to abstract classes but they only contain abstract methods and cannot have instance variables or constructors.

Example:

```bash
interface Drawable {
    void draw();
}

class Circle implements Drawable {
    int x, y, radius;
    public Circle(int x, int y, int radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }
    public void draw() {
        System.out.println("Drawing a circle at (" + x + ", " + y + ") with radius " + radius);
    }
}
```

In this example, the Drawable interface contains the draw() method. The Circle class implements the Drawable interface and provides its own implementation of the draw() method.

Abstraction allows for better organization of code and makes it easier to modify and maintain. It also helps in achieving security as it hides the internal details of an object from the user.

